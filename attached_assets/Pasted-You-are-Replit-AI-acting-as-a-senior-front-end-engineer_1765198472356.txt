You are Replit AI, acting as a senior front-end engineer and professional prompt engineer.

GOAL
Turn this imported Lovable project “Campus Prompt Palette” into a production-quality, front-end–only prompt-builder app that:

1) 탭별(레포트·에세이 / 시험 대비 / 코딩·Replit / 연구·논문 / 커리어·이메일 / 이미지 생성)로 전문적인 프롬프트를 생성한다.
2) 우측 “공통 설정”에서 지정한 옵션(모드, 분량/형식, 말투, 출처·자기검토, 프로필, 시간 압박, AI 규정, 모델/난이도)이 모두 최종 프롬프트 문자열에 반영된다.
3) 하단 “프롬프트 미리보기”와 “프롬프트 저장/불러오기” 기능이 완전하게 동작하며, 저장은 localStorage만 사용한다.
4) 외부 LLM API나 서버는 사용하지 않는다. 이 앱은 오직 “프롬프트 문자열 생성 + 저장/복사”만 한다.

GENERAL CONSTRAINTS
- Do NOT change the overall layout or page structure that came from Lovable.
  - Keep the header area, tab bar, left tab-specific form, right common settings + prompt library panel,
    and bottom preview area exactly as they are in terms of structure and positioning.
  - You may only wire new state/logic into existing components and add small subcomponents inside them
    (for example, a modal for saving prompt titles), without rearranging the layout.
- Do NOT significantly change existing Tailwind/shadcn UI styling. Only minor tweaks that are strictly
  necessary for new controls (e.g., a new button or input) are allowed.
- Do NOT add any backend, API routes, or database. This must remain a front-end–only app.
- Do NOT call any external LLM APIs. The app only builds prompt strings that the user will copy into
  ChatGPT, Gemini, etc.
- Keep all user-facing texts in Korean (except model names or necessary tags).
- Follow the existing Vite + TypeScript + React + shadcn-ui + Tailwind setup used in this repo.

STEP 1 – CREATE A CENTRAL PROMPT ENGINE

1. 프로젝트 구조를 확인한 뒤, 다음 파일을 추가한다 (폴더 구조가 다르면 가장 자연스러운 위치를 선택하되, 일관되게 유지):

  src/promptEngine/types.ts
  src/promptEngine/buildPrompt.ts
  src/promptEngine/tabBuilders.ts

2. types.ts에 TypeScript 타입(또는 JSDoc 타입)을 정의한다.

- export type TabId =
  | "reportEssay"
  | "exam"
  | "coding"
  | "research"
  | "careerEmail"
  | "image";

- export interface CommonSettings {
    mode: "learning" | "deliverable";          // 학습 모드 vs 과제/결과물 모드
    outlineMode: "outline" | "full";           // 아웃라인 중심 vs 완전 작성
    tonePreset:
      | "academic"
      | "report"
      | "casual"
      | "formalEmail"
      | "presentation";
    includeReferences: boolean;
    selfCheckEnabled: boolean;
    subjectProfile: {
      courseName?: string;
      majorOrGE?: string;
      level?: "HS" | "UG1" | "UG2" | "UG3" | "UG4" | "GR";
      professorStyle?: "strict" | "relaxed";
      assignmentType?: string;
    };
    userProfile: {
      major?: string;
      interests?: string;
      preferredExamples?: string;
    };
    styleSampleText?: string;
    timePressure?: {
      deadlineDescription?: string;   // 예: 내일 자정까지 제출
      examRemaining?: string;
    };
    aiPolicyText?: string;
    modelPreference?: "ChatGPT" | "Gemini" | "Other";
    languageLevel?: "HS" | "UG" | "GR";
  }

각 탭별 입력 타입도 정의한다.

- export interface ReportEssayInputs {
    assignmentSummary?: string;       // 과제 설명/지시문
    topic?: string;
    requiredSections?: string;        // 요구 목차/형식
    lengthTarget?: string;            // 분량(예: A4 2p, 10pt)
    keyPoints?: string;               // 반드시 포함할 논점
    prohibitedThings?: string;        // 피해야 할 것
    attachedMaterialSummary?: string; // 사용 중인 자료 요약
    stageCollectMaterial: boolean;    // 자료 조사/정리 단계 활성화 여부
    stageOutline: boolean;            // 아웃라인 단계
    stageDraft: boolean;              // 본문 작성 단계
  }

- export interface ExamInputs {
    examScope?: string;
    questionType?: string;            // 서술형/계산형/혼합 등
    myWeakPoints?: string;
    timeAvailable?: string;
    wantPracticeSet?: boolean;
    wantSummarySheet?: boolean;
  }

- export interface CodingInputs {
    goalDescription?: string;
    techStack?: string;
    constraints?: string;
    currentCodeSnippet?: string;
    wantStepPlan?: boolean;
    wantRefactor?: boolean;
  }

- export interface ResearchInputs {
    researchTopic?: string;
    researchQuestion?: string;
    methodology?: string;
    targetVenueOrClass?: string;
    existingWorkSummary?: string;
    lengthTarget?: string;
  }

- export interface CareerEmailInputs {
    emailType?: "professor" | "hr" | "networking" | "etc";
    purpose?: string;
    receiverProfile?: string;
    keyPoints?: string;
    lengthPreset?: string;
  }

- export interface ImageInputs {
    imageGoal?: string;
    subject?: string;
    style?: string;
    colorPalette?: string;
    resolutionOrRatio?: string;
    detailLevel?: "simple" | "medium" | "detailed";
    negativePrompt?: string;
  }

- export type TabInputs =
    | { tabId: "reportEssay"; data: ReportEssayInputs }
    | { tabId: "exam"; data: ExamInputs }
    | { tabId: "coding"; data: CodingInputs }
    | { tabId: "research"; data: ResearchInputs }
    | { tabId: "careerEmail"; data: CareerEmailInputs }
    | { tabId: "image"; data: ImageInputs };

3. buildPrompt.ts에서 공통 헬퍼와 메인 함수를 구현한다.

- export function buildPrompt(common: CommonSettings, tab: TabInputs): string

이 함수는 다음 구조의 문자열을 생성한다(모든 설명은 기본적으로 한국어):

[1] 역할 및 맥락 정의
- LLM에게 “한국 대학생을 돕는 전문 AI 어시스턴트” 역할을 부여하고,
- subjectProfile, userProfile, modelPreference, languageLevel을 이용해 대상 수준과 맥락을 지정한다.

[2] AI 규정 및 모드 설명
- aiPolicyText가 있으면 3~4문장으로 요약해서 규정 내에서만 답변하라고 지시한다.
- mode가 learning이면:
  - 정답을 바로 쓰지 말고, 학생의 이해를 확인하는 질문 → 설명 → 보충예시 순서를 따르도록 지시한다.
- mode가 deliverable이면:
  - 제출용 초안을 작성하되, 실제 제출 전에는 사용자가 수정·검토한다는 전제를 명시한다.

[3] 아웃라인/완전작성 설정
- outlineMode가 outline이면 “목차 구조, 각 단락의 주장·근거, 필요한 자료 리스트 위주로, 문장 길이는 짧게” 작성하도록 한다.
- outlineMode가 full이면 실제 완성본에 가까운 텍스트를 요구한다.

[4] 말투 설정
- tonePreset에 따라 한국어 말투를 구체적으로 지시한다.
  - academic: 학술적 보고서체, ~다/이다.
  - report: 교수 제출용 보고서, 공손하지만 과도하게 딱딱하지 않게.
  - casual: 친구에게 설명하듯, 존댓말/반말 여부는 자연스럽게.
  - formalEmail: 교수/HR에게 보내는 이메일용 극존대체.
  - presentation: 발표 대본용 구어체.

[5] 공통 옵션
- includeReferences가 true이면:
  - 주장·통계가 나올 때마다, 참고할 만한 자료 유형(논문, 보고서, 공신력 있는 웹사이트)을 제안하고, 실제 검증은 사용자가 한다고 명확히 적게 한다.
- selfCheckEnabled가 true이면:
  - 답변 마지막에:
    - (a) 본인 답변의 신뢰도(1~10점),
    - (b) 추가 검증이 필요한 부분 목록을 bullet로 작성하게 한다.

[6] 탭별 구체 지시
- 여기서 tabBuilders.ts의 서브 빌더를 호출한다 (다음 STEP 2 참고).

[7] Reflection / Flipped Interaction 패턴
- mode가 learning일 때:
  - “먼저 내가 이미 알고 있다고 가정되는 내용을 한 단락으로 정리한 뒤, 부족한 점을 지적하고, 내가 스스로 생각해볼 수 있는 질문을 1~3개 던진 후, 마지막에 모범 해설을 제시하라”고 지시한다.
- 모든 모드에서:
  - 답변 중간에 스스로 논리 빈틈을 점검하고, 필요하면 스스로 수정하도록 요구한다.


STEP 2 – TAB-SPECIFIC BUILDERS

tabBuilders.ts에서 각 탭 전용 함수를 구현한다.

- export function buildReportEssay(common: CommonSettings, data: ReportEssayInputs): string
- export function buildExam(common: CommonSettings, data: ExamInputs): string
- export function buildCoding(common: CommonSettings, data: CodingInputs): string
- export function buildResearch(common: CommonSettings, data: ResearchInputs): string
- export function buildCareerEmail(common: CommonSettings, data: CareerEmailInputs): string
- export function buildImage(common: CommonSettings, data: ImageInputs): string

각 함수는 공통 구조 안에서 “작업 지시(Task)” 부분을 채운다.

예시 요구사항:

1) buildReportEssay
- assignmentSummary, topic, requiredSections, lengthTarget, keyPoints, prohibitedThings, attachedMaterialSummary, stage* 값을 사용.
- stageCollectMaterial이 true이면:
  - 키워드 후보, 참고자료 유형, 자료 정리 방법을 먼저 제시하라고 지시.
- stageOutline이 true이면:
  - 서론–본론–결론 또는 과제에서 요구한 형식에 맞춰 목차/논점/근거를 구조화.
- stageDraft가 true이면:
  - lengthTarget과 tonePreset에 맞춰 문단 단위 초안을 작성.
- 모든 단계가 true인 경우:
  - “1단계 자료 조사, 2단계 아웃라인, 3단계 초안 작성” 순서로 나누어 답변하라고 명시.

2) buildExam
- examScope, questionType, myWeakPoints, timeAvailable, wantPracticeSet, wantSummarySheet 사용.
- wantSummarySheet가 true이면:
  - 시험 범위를 개념 맵 형태로 요약하고, 중요도/출제 가능성 표시.
- wantPracticeSet가 true이면:
  - 예상문제 세트(서술형/계산형)를 난이도 순으로 생성하고, 해설은 단계별 힌트→풀이→정답 순서로.
- learning 모드에서는 반드시 “먼저 학생에게 풀어볼 기회를 주고, 그 다음 단계별 해설” 패턴을 사용.

3) buildCoding
- goalDescription, techStack, constraints, currentCodeSnippet, wantStepPlan, wantRefactor 사용.
- 항상:
  - 요구 기능을 자신이 이해한 대로 다시 설명하게 하고,
  - step-by-step 구현 계획(폴더 구조, 주요 컴포넌트/함수)을 먼저 제시하게 함.
- wantStepPlan이 true이면:
  - 계획을 더 세분화하여 “1단계 환경 설정 → 2단계 최소 동작 예제 → 3단계 기능 확장” 식으로 명시.
- currentCodeSnippet이 제공되면:
  - 먼저 오류/리팩터링 포인트를 설명시키고, 개선된 코드와 그 이유를 제시하게 함.
- Replit 환경을 고려해:
  - “가능하면 단일 파일 또는 최소한의 의존성만 사용하고, 실행 방법을 주석으로 명시하라”고 지시.

4) buildResearch
- researchTopic, researchQuestion, methodology, targetVenueOrClass, existingWorkSummary, lengthTarget 사용.
- outline 모드:
  - 연구 목적, 연구 질문, 가설, 방법, 기대결과, 한계, 참고문헌 영역으로 나눈 구조를 생성.
- full 모드:
  - 연구계획서/초록/서론 중 어느 부분을 쓸지 사용자 입력에 따라 지정할 수 있도록 필드를 활용(필드가 없다면 기본은 “연구계획서 형식”).
- includeReferences가 true이면:
  - 선행연구 탐색 전략과 키워드, 데이터베이스 이름(예: Web of Science, Scopus, 국내 학술 DB 등)을 안내.

5) buildCareerEmail
- emailType, purpose, receiverProfile, keyPoints, lengthPreset 사용.
- emailType에 따라:
  - professor: 지도교수/수업 교수에게 보내는 이메일(예: 면담 요청, 마감 연장 요청, 추천서).
  - hr: 채용담당자용(지원서 제출, 후속 문의, 인터뷰 감사메일).
  - networking: 선배/현업자에게 네트워킹 및 조언 요청.
- 항상:
  - 제목, 인사, 본문(상황 설명 → 요청/감사 → 마무리), 서명 구조를 갖추고,
  - 한국어 극존대/공손체를 사용한다.
- lengthPreset이 “짧게/보통/길게” 중 하나라면, 문단 수와 문장 길이를 이에 맞추도록 지시.

6) buildImage
- imageGoal, subject, style, colorPalette, resolutionOrRatio, detailLevel, negativePrompt 사용.
- Nano-banana 등 이미지 생성기에서 그대로 붙여 넣을 수 있는 영어 중심 프롬프트를 생성하되,
  - 필요한 경우 한국어로 보충 설명을 달도록 한다.
- 구조:
  - Main subject and composition
  - Style and mood
  - Color palette (blue-based, “palette” 느낌의 다채로운 그라데이션 등)
  - Lighting and background
  - Resolution / aspect ratio
  - Negative prompts (원하지 않는 요소)


STEP 3 – WIRE THE ENGINE INTO THE EXISTING REACT UI

1. 현재 탭/폼/공통 설정 컴포넌트 위치를 찾는다.
   - 예: src/App.tsx, src/components/Tabs/…, src/components/CommonSettingsPanel.tsx 등.

2. 최상위에서 다음 상태를 관리한다 (useState 또는 useReducer 사용):

- commonSettings: CommonSettings
- activeTabId: TabId
- per-tab inputs: ReportEssayInputs, ExamInputs, … 등을 각각 별도의 상태로 관리.
- previewPrompt: string
- savedPrompts: PromptItem[]

PromptItem 타입:

- interface PromptItem {
    id: string;              // uuid 또는 timestamp 기반
    title: string;
    tabId: TabId;
    createdAt: string;       // ISO string
    prompt: string;
  }

3. “프롬프트 생성” 버튼 클릭 시:

- 현재 activeTabId에 맞는 TabInputs 객체를 만든다.
- buildPrompt(commonSettings, tabInputs)를 호출한다.
- 반환된 문자열을 previewPrompt에 저장하고, 하단 미리보기 textarea에 표시한다.

4. 프롬프트 보관함(localStorage) 구현

- 별도의 유틸/훅을 만든다 (예: src/hooks/usePromptLibrary.ts):

  - localStorage key는 "campus-prompt-palette-library" 로 통일.
  - 초기 렌더 시:
    - localStorage에서 해당 key를 읽어 savedPrompts 배열로 파싱.
  - 함수:
    - addPrompt(item: PromptItem)
    - removePrompt(id: string)
    - clearAll()
  - add/remove 호출 후 항상 localStorage에 JSON 직렬화하여 저장.

- UI 요구사항:
  - “프롬프트 저장하기” 버튼 클릭 시:
    - title을 입력받는 간단한 모달/폼(또는 window.prompt)을 띄운다.
    - previewPrompt가 비어 있으면 저장하지 않고 경고 메시지.
    - 새 PromptItem 생성 → savedPrompts에 추가.
  - 보관함 리스트에는:
    - title, tabId, createdAt, 앞부분 일부(미리보기)를 표시.
    - 버튼:
      - “복사”: navigator.clipboard.writeText(item.prompt)
      - “불러오기”: previewPrompt를 item.prompt로 교체하고, 필요하면 activeTabId도 item.tabId로 변경.
      - “삭제”: removePrompt 호출.

5. 기존 레이아웃과 디자인은 최대한 유지하되:

- 버튼 라벨, 설명 문구는 위 로직에 맞게만 보완한다.
- 새로운 상태/함수를 컴포넌트 props로 넘겨 UI와 로직을 연결한다.


STEP 4 – EXECUTION PLAN

1. 먼저 프로젝트 파일 구조를 스캔하고, 현재 프롬프트 관련 로직/상태가 있는지 확인한 뒤, 위 설계에 맞게 어느 파일을 수정/추가할지 짧게 요약한다.
2. types.ts, tabBuilders.ts, buildPrompt.ts를 생성하고, 완전한 코드 내용을 제시한다.
3. 최상위 App 및 각 탭 컴포넌트에 상태/이벤트 연결 코드를 추가하고, 전체 파일 내용을 보여 준다.
4. 마지막으로:
   - 변경된 파일 목록,
   - 이 앱을 Replit에서 실행하는 방법 (예: npm install → npm run dev 혹은 현재 스크립트에 맞게),
   - 각 탭에서 프롬프트를 생성하고 저장/불러오기/복사하는 사용 흐름을 간단히 설명한다.

Now inspect the current Repl, then implement these steps carefully without changing the overall layout.
